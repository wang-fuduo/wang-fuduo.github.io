---
title: 快速排序
date: 2024-11-24 00:00:00 +0800
categories: [算法]
tags: [排序, 快速排序, 算法]
math: true
image:
   path: assets/2024-11-23-快速排序/quickSort.gif
   alt: 封面图
---

![quickSort](assets/2024-11-23-快速排序/quickSort.gif)

## 1. 什么是快速排序

今天我们介绍的算法是**快速排序**，又是一个有关**排序**的算法。正如它的名字所表达的那样，快速排序的最大优点在于它的速度非常快。在有些时候要比堆排序、归并排序等优秀算法更加快速。

**快速排序的基本思想与归并排序的一样，主打一个分治**。其整体思路如下：

1. 选定一个数num作为中间值
2. 将比num小的数放在其左边，比num大的数放在其右边
3. 分别对num左侧和右侧的新数组进行前两步操作
4. 直到最终新数组只剩下1个元素，排序完成

接下来通过图示的方式展示一下快排的策略。

## 2. 快排图示

首先这里有一组无序数组，我们用长度不同的矩形表示。

![无序数组](assets/2024-11-23-快速排序/无序数组.png)

我们从中随机选取一个数字最为**中间值**。

![选择中间值](assets/2024-11-23-快速排序/选择中间值.png)

现在，将所有小于中间值的元素放在中间值的**左侧**，大于它的放在它的**右侧**。

![左右两侧分布](assets/2024-11-23-快速排序/左右两侧分布.png)

现在可以看到，在中间值左侧的元素都比它矮，右侧的都比它高。我们将中间值左侧的元素视为**新的数组**，并从中随机选取**中间值**。

![小数组选中间值](assets/2024-11-23-快速排序/小数组选中间值.png)

然后，对左侧的新数组进行同样的操作；将小于中间值的放在左侧，大于它的放在右侧。

![小数组分布](assets/2024-11-23-快速排序/小数组分布.png)

现在可以看到，左侧小数组还可以进行进一步划分。中间值的左侧没有元素，相当于**数组为空**，我们不考虑。中间值的右侧有元素，再一次建立小数组。并且，在这个小数组里，再一次随机选择中间值。

![小小数组选数](assets/2024-11-23-快速排序/小小数组选数.png)

最后，对这个小小数组再进行一次排列，小放左，大放右。

![小小数组完成](assets/2024-11-23-快速排序/小小数组完成.png)

此时，小小数组里面中间值的左侧没有元素，不考虑；中间值的右侧有元素，而右侧形成的数组**长度为1**，本身就是**有序的**，所以无需处理。这样我们发现，对于刚开始时候选择的中间值，其左侧已经排列完全。

![左侧完成](assets/2024-11-23-快速排序/左侧完成.png)

运用同样的方式，对中间值右侧的数组进行处理，最终可得到一个从小到大排列完全的数组。

![排列完成](assets/2024-11-23-快速排序/排列完成.png)

由此可见，快排本身的思想还是**分治**。对形成的小数组以**递归**的方式层层调用快排函数，直到数组长度为0或1，即可停止**递归**。**所以其中最重要的操作，是大小分类（即 将比中间值小的放左边，大的放右边）**。

来一段`C++`：

```C++
// 快排主体
// 选定中值元素，调用分割函数
// 再对分割好的左右两个子数组快排
void QuickSort(int left, int right)
{
    if(right <= left)  // 如果左右指针重合，证明只有一个元素
        return;
    int middle = Partition(left, right);  // 分割并获取中间元素下标
    // 分别快排
    QuickSort(left, middle - 1);
    QuickSort(middle + 1, right);
}
```

## 3. 如何进行大小分类
